package uc3m.crypto.server.model;

import uc3m.crypto.security.RSA;
import uc3m.crypto.security.SHA;
import uc3m.crypto.security.X509;

import javax.crypto.SecretKey;
import java.io.Serializable;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SignatureException;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.text.SimpleDateFormat;
import java.util.Base64;
import java.util.Date;

import static uc3m.crypto.server.model.Message.SignatureStatus.*;
import static uc3m.crypto.server.model.Message.SignatureStatus.UNSIGNED;

public class Message implements Serializable {
    private String sender;
    private String content;
    private Date dateSent;
    private String hmac;
    private String sig;
    private String receiver;

    public Message(String sender, String content, Date dateSent) {
        this.sender = sender;
        this.content = content;
        this.dateSent = dateSent;
        this.receiver = "";
        this.hmac = "";
        this.sig = "";
    }

    public Message(String message) { //Message from string, the same as generated by toString()
        sender = message.substring(message.indexOf("sender") + 8,
                message.indexOf("'", message.indexOf("sender") + 8));
        String date = message.substring(message.indexOf("dateSent") + 10,
                message.indexOf("'", message.indexOf("dateSent") + 10));
        SimpleDateFormat dateFormatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        try {
            dateSent = dateFormatter.parse(date);
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        hmac = message.substring(message.indexOf("hmac") + 6,
                message.indexOf("'", message.indexOf("hmac") + 6));
        receiver = message.substring(message.indexOf("receiver") + 10,
                message.indexOf("'", message.indexOf("receiver") + 10));
        sig = message.substring(message.indexOf("sig") + 5,
                message.indexOf("'", message.indexOf("sig") + 5));
        content = message.substring(message.indexOf("content") + 9, message.length()-2);
    }

    public Message(String message, SecretKey key) {
        this(message);
        this.checkHmac(key);
    }

    @Override
    public String toString() {
        SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        return "Message{" +
                "sender='" + sender + '\'' +
                ", dateSent='" + formatter.format(dateSent) + '\'' +
                ", hmac='" + hmac + '\'' +
                ", receiver='" + receiver + '\'' +
                ", sig='" + sig + '\'' +
                ", content='" + content + '\'' +
                '}';
    }

    public String toStringWithoutHmac() { //to string without HMAC for HMAC generation
        SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        return "Message{" +
                "sender='" + sender + '\'' +
                ", dateSent='" + formatter.format(dateSent) + '\'' +
                ", receiver='" + receiver + '\'' +
                ", content='" + content + '\'' +
                '}';
    }

    public enum SignatureStatus {
        UNSIGNED, SIGNATURE_VALID, SIGNATURE_INVALID, CERTIFICATE_NOT_FOUND
    }

    public String toUIString(SignatureStatus signatureStatus) { //this string is printed on the user interface
        SimpleDateFormat formatter = new SimpleDateFormat("HH:mm:ss");
        String icon = "";
        switch (signatureStatus) {
            case UNSIGNED:
                icon = "";
                break;
            case SIGNATURE_VALID:
                icon = "ðŸ–‹";
                break;
            case SIGNATURE_INVALID:
                icon = "ðŸš«";
                break;
            case CERTIFICATE_NOT_FOUND:
                icon = "?";
                break;
            default:
                break;
        }
        return "(" + formatter.format(dateSent) + ")[" + sender + "]" + icon + ": " + content;
    }

    public String toUIString() {
        return toUIString(checkSignature());
    }

    public SignatureStatus checkSignature() {
        Message.SignatureStatus signatureStatus = UNSIGNED;
        if (!getSig().equals("")) {
            X509Certificate senderCert = X509.getUserCertificate(getSender());
            if (senderCert == null) {
                //controller.writeLine("Signed but the certificate not found.");
            }
            else {
                if (!verifySignature(senderCert.getPublicKey())) {
                    //controller.writeLine("Signature invalid!");
                    signatureStatus = SIGNATURE_INVALID;
                }
                else {
                    signatureStatus = SIGNATURE_VALID;
                }
            }
        }
        else {
            signatureStatus = UNSIGNED;
        }
        return signatureStatus;
    }

    public String getHmacString(SecretKey key) { //get HMAC value of the message as Base64 string
        return Base64.getEncoder().encodeToString(SHA.digest(this.toStringWithoutHmac()
                + Base64.getEncoder().encodeToString(key.getEncoded())));
    }
    public boolean checkHmac(SecretKey key) { //check if the newly generated HMAC equals to the saved one, integrity check
        if (getHmacString(key).equals(hmac)) {
            return true;
        }
        else {
            throw new SecurityException("Message integrity compromised");
        }
    }

    public String getHash() {
        return Base64.getEncoder().encodeToString(SHA.digest(this.toStringWithoutHmac()));
    }

    public void sign(PrivateKey key) {
        setSig(RSA.sign(toStringWithoutHmac(), key));
    }
    public boolean verifySignature(PublicKey key) {
        return RSA.verifySignature(toStringWithoutHmac(), key, getSig());
    }
    public void encrypt(Certificate cert) {
        content = RSA.encrypt(content, cert);
    }
    public void decrypt(PrivateKey privateKey) {
        content = RSA.decrypt(content, privateKey);
    }

    public String getSender() {
        return sender;
    }

    public void setSender(String sender) {
        this.sender = sender;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public Date getDateSent() {
        return dateSent;
    }

    public void setDateSent(Date dateSent) {
        this.dateSent = dateSent;
    }

    public String getHmac() {
        return hmac;
    }

    public Message setHmac(SecretKey key) {
        this.hmac = getHmacString(key);
        return this;
    }

    public String getReceiver() {
        return receiver;
    }

    public void setReceiver(String receiver) {
        this.receiver = receiver;
    }

    public String getSig() {
        return sig;
    }

    public void setSig(String sig) {
        this.sig = sig;
    }
}
